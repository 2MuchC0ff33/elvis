#!/bin/sh
# bin/elvis-run
# Master orchestrator for Elvis initialisation sequence

set -eu

show_help() {
  echo "Usage: $0 init | get-transaction-data | set-status | end-sequence | choose-dork | update-config | help"
  echo "  init                  Run initialisation sequence (load env, config, pagination, validate, log)"
  echo "  get-transaction-data  Run transaction data workflow (seeds, normalise, split, pagination, fetch)"
  echo "  set-status            Run the 'set status' workflow for results.csv (enrich -> validate -> dedupe -> output)"
  echo "  end-sequence          Run the end-sequence workflow: archive, cleanup, summarise"
  echo "  choose-dork           Interactive: select a Google dork template and open in browser"
  echo "  update-config         Synchronise keys between project.conf and .env.example"
  echo "  help                  Show this help"
  exit 0
}
usage() {
  cat <<EOF
elvis-run [init|get-transaction-data|set-status|end-sequence|choose-dork|help]
  init                  Run initialisation sequence
  get-transaction-data  Run transaction data workflow (seeds, normalise, split, pagination, fetch)
  set-status            Run the 'set status' workflow for results.csv (enrich -> validate -> dedupe -> output)
  end-sequence          Run the end-sequence workflow: archive, cleanup, summarise
  choose-dork           Interactive: select a Google dork template and open in browser
  help                  Show this help
EOF
  exit 0
}

ORIG_ARGS="$*"

source_clear() {
  # Source a script with positional args cleared to avoid passing top-level
  # arguments (e.g., 'init') into sourced scripts that use positional params.
  # Usage: source_clear /path/to/script.sh [optional args to pass to it]
  restore="$ORIG_ARGS"
  script="$1"
  # remove the script path from the function args; remaining args (if any)
  # are intended to be passed to the sourced script.
  shift
  set --
  if [ "$#" -gt 0 ]; then
    # set any explicit args for the sourced script
    set -- "$*"
  fi
  # Let ShellCheck follow these possible dynamic sources
  # shellcheck source=../scripts/lib/load_env.sh
  # shellcheck source=../scripts/lib/load_config.sh
  # shellcheck source=../scripts/lib/load_seek_pagination.sh
  # shellcheck source=../scripts/lib/validate_env.sh
  # shellcheck source=../scripts/lib/prepare_log.sh
  . "$script"
  # restore original args for elvis-run
  set -- "$restore"
}

case "${1:-}" in
  init)
    # shellcheck source=../scripts/lib/load_env.sh
    source_clear "$(dirname "$0")/../scripts/lib/load_env.sh"

    # shellcheck source=../scripts/lib/load_config.sh
    source_clear "$(dirname "$0")/../scripts/lib/load_config.sh"

    # shellcheck source=../scripts/lib/load_seek_pagination.sh
    source_clear "$(dirname "$0")/../scripts/lib/load_seek_pagination.sh"

    # shellcheck source=../scripts/lib/validate_env.sh
    source_clear "$(dirname "$0")/../scripts/lib/validate_env.sh"

    # shellcheck source=../scripts/lib/prepare_log.sh
    source_clear "$(dirname "$0")/../scripts/lib/prepare_log.sh"

    echo "[elvis-run] Initialisation complete."
    ;;
  help|-h|--help)
    sh "$(dirname "$0")/../scripts/init-help.sh"
    ;;
  get-transaction-data)
    exec "$(dirname "$0")/../scripts/get_transaction_data.sh"
    ;;
  set-status)
    # forward remaining args to set_status.sh
    shift
    exec "$(dirname "$0")/../scripts/set_status.sh" "$@"
    ;;
  end-sequence)
    shift
    exec "$(dirname "$0")/../scripts/end_sequence.sh" "$@"
    ;;
  choose-dork)
    shift
    exec "$(dirname "$0")/../scripts/choose_dork.sh" "$@"
    ;;
  update-config)
    shift
    exec "$(dirname "$0")/../scripts/update_config_examples.sh" "$@"
    ;;
  *)
    show_help
    ;;
esac
